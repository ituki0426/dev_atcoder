## 0-1BFS

0-1BFSは辺のコストが０、１のみに限ることを利用してDijkstraにおけるpriority_queurの部分をdequeみすることで計算量を落とす手法です。

Dijkstraの計算量が O(V+ElovV)であるのに対し、0-1BFSでは、O(V+E)も落ちる。

## Bishop_2.cpp

### (1)問題文

---

N×N
 のグリッドが与えられます。各マスは通路 (文字 . で表される) と壁 (文字 # で表される) のいずれかです。

今あなたは座標 (Ax, Ay) にいます。ここから「ビショップの移動」を繰り返して座標 (Bx, By) に到達したいとします。そのための最小手数を答えてください。到達不可能な場合は -1 と出力してください。

なおビショップの移動とは「斜め四方向に、壁にぶつからない限りはどこまでも移動できる」というものです。壁を通り抜けたり、盤面外に出たりすることはできません。

### (2)BFSでは間に合わない

---

迷路の最短路はBFSの典型問題です。

ただし、通常の迷路の最短路問題では、１回で移動できるますが上下に隣接する４マスしかないのに対し、今回の問題では１回でO(N)個のマスに移動できる
BFSの計算量はグラフの辺数Eに対してO(E)です。

１回で移動できる場所がO(N)となると、グラフの辺数はO(N^3)となり、TLEになる。

### (3)ノードに「移動方向」を持たせて１マスづつ移動する

- 各頂点が（縦方向座表、横方向座標、前回の移動方向）を表すグラフを考える。
- 各頂点に対して、斜め四方向に進んだ４マスにのみ辺を張る。
 - 移動方向が前回のものと一致するときは「辺のコスト:0」
 - 移動方向が前回のものと異なるときは「辺のコスト：１」

こうしてグラフの変数がO(N^2)で抑えられる。

ただし、下のグラフでは辺のコストが全て１だと見做せたのに対し、今回は辺のコストが０と１がありうることになる。

普通のBFSではダメなので、0-1BFSを使う。


